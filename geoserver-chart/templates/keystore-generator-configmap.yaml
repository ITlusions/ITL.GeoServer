{{- if and .Values.https.enabled .Values.https.autoGenerateKeystore (not .Values.https.keystoreSecret) }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "geoserver.fullname" . }}-keystore-script
  labels:
    {{- include "geoserver.labels" . | nindent 4 }}
    app.kubernetes.io/component: keystore-generator
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-15"
    "helm.sh/hook-delete-policy": before-hook-creation
data:
  generate-keystore.sh: |
    #!/bin/bash
    set -euo pipefail
    
    echo "Starting keystore generation..."
    echo "Domain: $DOMAIN_NAME"
    echo "Organization: $ORGANIZATION"
    echo "Country: $COUNTRY"
    echo "Validity: $VALIDITY_DAYS days"
    
    # Check if secret already exists
    if kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" >/dev/null 2>&1; then
        echo "Secret $SECRET_NAME already exists. Checking if keystore is present..."
        if kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" -o jsonpath='{.data.keystore\.jks}' | base64 -d > /dev/null 2>&1; then
            echo "Keystore already exists in secret. Skipping generation."
            exit 0
        else
            echo "Secret exists but no keystore found. Will add keystore to existing secret."
            UPDATE_EXISTING=true
        fi
    else
        echo "Secret does not exist. Will create new secret."
        UPDATE_EXISTING=false
    fi
    
    # Generate private key
    echo "Generating private key..."
    openssl genrsa -out /tmp/server.key 2048
    
    # Create certificate signing request
    echo "Creating certificate signing request..."
    openssl req -new -key /tmp/server.key -out /tmp/server.csr \
        -subj "/CN=$DOMAIN_NAME/O=$ORGANIZATION/C=$COUNTRY"
    
    # Create certificate extensions file
    cat > /tmp/server.ext << EOF
    authorityKeyIdentifier=keyid,issuer
    basicConstraints=CA:FALSE
    keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
    subjectAltName = @alt_names
    
    [alt_names]
    DNS.1 = $DOMAIN_NAME
    DNS.2 = localhost
    DNS.3 = *.svc.cluster.local
    DNS.4 = *.${NAMESPACE}.svc.cluster.local
    IP.1 = 127.0.0.1
    EOF
    
    # Generate self-signed certificate
    echo "Generating self-signed certificate..."
    openssl x509 -req -in /tmp/server.csr -signkey /tmp/server.key \
        -out /tmp/server.crt -days "$VALIDITY_DAYS" \
        -extensions v3_req -extfile /tmp/server.ext
    
    # Create PKCS12 keystore
    echo "Creating PKCS12 keystore..."
    openssl pkcs12 -export -in /tmp/server.crt -inkey /tmp/server.key \
        -out /tmp/keystore.p12 -name "$KEY_ALIAS" \
        -password pass:"$KEYSTORE_PASSWORD"
    
    # Convert to JKS keystore
    echo "Converting to JKS keystore..."
    keytool -importkeystore \
        -srckeystore /tmp/keystore.p12 -srcstoretype PKCS12 \
        -destkeystore "$KEYSTORE_PATH" -deststoretype JKS \
        -srcstorepass "$KEYSTORE_PASSWORD" \
        -deststorepass "$KEYSTORE_PASSWORD" \
        -noprompt
    
    # Verify keystore
    echo "Verifying keystore..."
    keytool -list -keystore "$KEYSTORE_PATH" -storepass "$KEYSTORE_PASSWORD" -v
    
    # Base64 encode keystore
    echo "Encoding keystore..."
    KEYSTORE_B64=$(base64 -w 0 "$KEYSTORE_PATH")
    
    if [ "$UPDATE_EXISTING" = "true" ]; then
        echo "Updating existing secret with keystore..."
        kubectl patch secret "$SECRET_NAME" -n "$NAMESPACE" \
            --patch="{\"data\":{\"keystore.jks\":\"$KEYSTORE_B64\"}}" \
            --type=merge
    else
        echo "Creating new secret with keystore and password..."
        kubectl create secret generic "$SECRET_NAME" -n "$NAMESPACE" \
            --from-literal=keystorePassword="$KEYSTORE_PASSWORD" \
            --from-literal=keystore.jks="$KEYSTORE_B64" \
            --dry-run=client -o yaml | kubectl apply -f -
    fi
    
    # Add labels and annotations to the secret
    kubectl label secret "$SECRET_NAME" -n "$NAMESPACE" \
        app.kubernetes.io/name={{ include "geoserver.name" . }} \
        app.kubernetes.io/instance={{ .Release.Name }} \
        app.kubernetes.io/managed-by={{ .Release.Service }} \
        app.kubernetes.io/component=https-keystore \
        --overwrite
    
    kubectl annotate secret "$SECRET_NAME" -n "$NAMESPACE" \
        generated-by=geoserver-keystore-generator \
        generated-at="$(date -Iseconds)" \
        domain-name="$DOMAIN_NAME" \
        validity-days="$VALIDITY_DAYS" \
        --overwrite
    
    echo "Keystore generation completed successfully!"
    echo "Secret: $SECRET_NAME"
    echo "Keystore password: [HIDDEN]"
    echo "Domain: $DOMAIN_NAME"
    echo "Valid for: $VALIDITY_DAYS days"
    
    # Clean up temporary files
    rm -f /tmp/server.key /tmp/server.csr /tmp/server.crt /tmp/server.ext /tmp/keystore.p12
    
    echo "Cleanup completed."
{{- end }}
